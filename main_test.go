package main_test

import (
	"bytes"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"strings"
	"testing"

	"github.com/sqlc-dev/plugin-sdk-go/plugin"
	sqlcpluginbulkgo "github.com/tomtwinkle/sqlc-plugin-bulk-go"
	"gotest.tools/v3/assert"
)

func TestGenerate(t *testing.T) {
	t.Parallel()

	type Args struct {
		req *plugin.GenerateRequest
	}
	type Expected struct {
		err error
	}

	tests := map[string]struct {
		arrange func(*testing.T) (Args, Expected)
	}{
		"valid:Normal INSERT Query": {
			arrange: func(t *testing.T) (Args, Expected) {
				req := &plugin.GenerateRequest{
					SqlcVersion:   "1.0.0",
					PluginOptions: []byte(`{"package": "sqlc"}`),
					Queries: []*plugin.Query{
						{
							Name: "InsertUser",
							Text: "INSERT INTO users (id, name) VALUES (?, ?)",
							Params: []*plugin.Parameter{
								{Column: &plugin.Column{Name: "id"}},
								{Column: &plugin.Column{Name: "name"}},
							},
						},
					},
				}
				return Args{req: req}, Expected{err: nil}
			},
		},
		"valid:Extra suffix INSERT Query": {
			arrange: func(t *testing.T) (Args, Expected) {
				req := &plugin.GenerateRequest{
					SqlcVersion:   "1.0.0",
					PluginOptions: []byte(`{"package": "sqlc"}`),
					Queries: []*plugin.Query{
						{
							Name: "InsertUser",
							Text: "INSERT INTO users (id, name) VALUES (?, ?) ON DUPLICATE KEY UPDATE id = id",
							Params: []*plugin.Parameter{
								{Column: &plugin.Column{Name: "id"}},
								{Column: &plugin.Column{Name: "name"}},
							},
						},
					},
				}
				return Args{req: req}, Expected{err: nil}
			},
		},
	}

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			args, want := tc.arrange(t)

			got, err := sqlcpluginbulkgo.Generate(t.Context(), args.req)
			if want.err != nil {
				assert.ErrorContains(t, err, want.err.Error())
				return
			}
			assert.NilError(t, err)
			assert.Assert(t, len(got.Files) > 0, "Expected at least one generated file, got none")

			// TODO: Need the code generated by sqlc-gen-go
			// assertGeneratedCodeIsValid(t, got.Files)
			t.Log(string(bytes.Replace(got.Files[0].Contents, []byte("\\n"), []byte("\n"), -1)))
		})
	}
}

func assertGeneratedCodeIsValid(t *testing.T, files []*plugin.File) {
	t.Helper()

	fset := token.NewFileSet()
	var parsedFiles []*ast.File

	for _, file := range files {
		if !strings.HasSuffix(file.Name, ".go") {
			continue
		}

		node, err := parser.ParseFile(fset, file.Name, file.Contents, parser.ParseComments)
		if err != nil {
			t.Fatalf("Failed to parse file %s: %v", file.Name, err)
		}
		parsedFiles = append(parsedFiles, node)
	}
	if len(parsedFiles) == 0 {
		return
	}
	conf := types.Config{
		Importer: importer.Default(),
		Error: func(err error) {
			t.Fatalf("Failed to type check generated code: %v", err)
		},
	}
	pkgPath := parsedFiles[0].Name.Name
	_, err := conf.Check(pkgPath, fset, parsedFiles, nil)
	if err != nil {
		t.Fatalf("Type checking failed for generated code: %v", err)
	}
}
